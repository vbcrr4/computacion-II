1. Fundamentos de procesos

Empecemos con lo esencial: Â¿quÃ© es un proceso en un sistema operativo?
DefiniciÃ³n formal de proceso

Un proceso es una instancia en ejecuciÃ³n de un programa. Mientras que un programa es un conjunto de instrucciones almacenadas en un archivo ejecutable, un proceso es ese programa cargado en memoria y en ejecuciÃ³n, gestionado por el sistema operativo.

Cada proceso tiene varios atributos importantes:

    PID (Process ID): Un identificador Ãºnico asignado por el sistema.

    PPID (Parent Process ID): Identificador del proceso padre.

    Estado: Puede estar en ejecuciÃ³n, esperando, suspendido o finalizado.

    Espacio de memoria: Incluye cÃ³digo, datos y pila de ejecuciÃ³n.

    Recursos asignados: Como archivos abiertos y uso de CPU.

Diferencias entre programa y proceso
CaracterÃ­stica	Programa	Proceso
Estado	Archivo en disco	Entidad en ejecuciÃ³n en RAM
Identificador	No tiene	PID asignado por el SO
Recursos	No usa recursos	Consume CPU, memoria, archivos abiertos
Multiplicidad	Un Ãºnico archivo	Puede haber mÃºltiples procesos ejecutando el mismo programa

Ejemplo: Si ejecutas python script.py tres veces, tendrÃ¡s tres procesos del mismo programa.
Historia y evoluciÃ³n del concepto de procesos

Los primeros sistemas operativos no tenÃ­an multitarea: ejecutaban un solo programa a la vez. Con el tiempo, surgieron los sistemas multiprogramados, permitiendo mÃºltiples procesos en ejecuciÃ³n simultÃ¡nea, optimizando el uso del procesador y la memoria.

Hoy en dÃ­a, los sistemas operativos modernos usan planificaciÃ³n de procesos y tÃ©cnicas como context switching para gestionar la ejecuciÃ³n de mÃºltiples procesos eficientemente.
ðŸ“Œ Alto para puesta en comÃºn

Antes de seguir, verifica que has entendido los conceptos bÃ¡sicos.
Preguntas de comprensiÃ³n:

    Â¿CuÃ¡l es la diferencia principal entre un programa y un proceso?
    1.Un programa es un conjunto de instrucciones almacenadas en un archivo, mientras que un proceso es una instancia en ejecuciÃ³n de un programa, con recursos asignados como memoria y CPU.
    Â¿QuÃ© es un PID y por quÃ© es importante?
    2.El PID (Process ID) es un nÃºmero Ãºnico que identifica a cada proceso en el sistema. Es importante porque permite gestionar y controlar los procesos en ejecuciÃ³n.
    Â¿QuÃ© sucede si ejecutamos el mismo programa varias veces?
    3.Cada ejecuciÃ³n genera un proceso distinto con su propio PID, pudiendo ejecutarse de manera independiente o compartir ciertos recursos segÃºn el sistema operativo.
2. El modelo de procesos en UNIX/Linux

En los sistemas UNIX/Linux, los procesos siguen una jerarquÃ­a bien definida. Veamos cÃ³mo funciona.
JerarquÃ­a de procesos y herencia

Cada proceso en UNIX tiene un proceso padre (PPID) y puede generar procesos hijos.
Esta estructura forma un Ã¡rbol de procesos, donde:

    El primer proceso en el sistema (PID = 1) es init o systemd, que genera otros procesos.

    Los procesos hijos pueden crear mÃ¡s procesos, formando una jerarquÃ­a.

Puedes visualizar esto con:

pstree -p

Ejemplo de jerarquÃ­a:

systemd(1)â”€â”¬â”€sshd(1000)â”€â”€â”€bash(2000)â”€â”€â”€python3(3000)
           â”œâ”€cron(1010)
           â”œâ”€nginx(1020)â”€â”¬â”€nginx(1021)
           â”‚             â””â”€nginx(1022)

AquÃ­ systemd es el padre de todos, bash iniciÃ³ un proceso python3, y nginx creÃ³ mÃºltiples procesos hijos.
El proceso init / systemd

El primer proceso que se ejecuta en UNIX/Linux es:

    init (en sistemas antiguos)

    systemd (en sistemas modernos como Ubuntu, Fedora, Arch, etc.)

Este proceso es responsable de:

    Iniciar otros procesos esenciales.

    Administrar servicios del sistema.

    Adoptar procesos huÃ©rfanos (explicaremos esto despuÃ©s).

Para ver el proceso systemd:

ps -fp 1

VisualizaciÃ³n de procesos con herramientas del sistema

Ejercicios prÃ¡cticos:

    Listar los procesos activos:

ps -e

Ver los procesos de un usuario especÃ­fico (ejemplo: "juan"):

ps -u juan

Mostrar la jerarquÃ­a completa de procesos:

pstree -p

Filtrar por un proceso especÃ­fico (ejemplo: bash):

    ps aux | grep bash

ðŸ“Œ Alto para puesta en comÃºn

Prueba estos comandos y verifica que puedas ver los procesos en tu sistema.
Preguntas de comprensiÃ³n:

    Â¿CÃ³mo se organizan los procesos en UNIX/Linux?

    Â¿CuÃ¡l es la funciÃ³n del proceso init o systemd?

    Â¿QuÃ© comando puedes usar para ver la jerarquÃ­a de procesos en ejecuciÃ³n?
    1.Los procesos se organizan en una estructura jerÃ¡rquica, donde cada proceso tiene un padre y puede tener hijos. Esta relaciÃ³n se maneja a travÃ©s de PIDs y PPIDs (Parent Process ID).
    2.Son los primeros procesos que se ejecutan al arrancar el sistema y se encargan de iniciar, gestionar y supervisar otros procesos esenciales.
    3.Se puede usar pstree para visualizar los procesos en forma de Ã¡rbol y entender su relaciÃ³n entre ellos.
3. ManipulaciÃ³n de procesos con Python

Ahora aprenderemos a crear y gestionar procesos en Python utilizando el mÃ³dulo os.
CreaciÃ³n de procesos con fork()

El sistema UNIX/Linux permite a un proceso crear un nuevo proceso con fork().
Cuando un proceso llama a fork():

    Se duplica el proceso actual, creando un hijo.

    Ambos procesos continÃºan ejecutÃ¡ndose desde el mismo punto.

    El proceso padre recibe el PID del hijo, mientras que el hijo recibe 0.

ðŸ“Œ Ejemplo de uso:

import os

pid = os.fork()  # Crea un nuevo proceso

if pid > 0:
    print(f"Proceso padre (PID: {os.getpid()}), hijo PID: {pid}")
else:
    print(f"Proceso hijo (PID: {os.getpid()}), padre PID: {os.getppid()}")

ðŸ”¹ Ejecuta esto en la terminal y observa la salida.
Ejecutar otro programa con exec()

Una vez que un proceso ha hecho fork(), puede reemplazar su cÃ³digo con un nuevo programa usando exec().

ðŸ“Œ Ejemplo:
Este cÃ³digo crea un proceso hijo que ejecuta ls -l usando execvp().

import os

pid = os.fork()

if pid == 0:  # CÃ³digo del hijo
    os.execvp("ls", ["ls", "-l"])
else:
    os.wait()  # El padre espera a que el hijo termine
    print("Proceso hijo finalizado.")

ðŸ”¹ Ejecuta esto y observa cÃ³mo el hijo ejecuta ls -l.
Esperar la terminaciÃ³n de un proceso hijo (wait())

Cuando un proceso padre crea un hijo, puede esperar a que termine con wait(), evitando que queden procesos "zombis".

ðŸ“Œ Ejemplo:

import os
import time

pid = os.fork()

if pid == 0:  # CÃ³digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecutÃ¡ndose...")
    time.sleep(2)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # CÃ³digo del padre
    print(f"Padre (PID {os.getpid()}) esperando al hijo...")
    os.wait()  # Espera a que el hijo termine
    print("El proceso hijo ha terminado.")

ðŸ”¹ Ejecuta esto y observa el comportamiento.
ðŸ“Œ Alto para puesta en comÃºn

Ejecuta los ejemplos y verifica que comprendes cÃ³mo funcionan fork(), exec(), y wait().
Preguntas de comprensiÃ³n:

    Â¿QuÃ© hace fork() en un programa Python?

    Â¿CÃ³mo puede un proceso hijo ejecutar otro programa?

    Â¿Por quÃ© es importante que el proceso padre use wait()?
    1.Crea un nuevo proceso duplicando el actual. El proceso hijo recibe una copia del estado del padre y ejecuta el mismo cÃ³digo desde el punto del fork().
    2.Puede usar exec() para reemplazar su cÃ³digo por el de otro programa, ejecutÃ¡ndolo en su propio espacio de proceso.
    3.Para evitar procesos zombie y asegurarse de que el hijo termine correctamente, liberando sus recursos.
4. Procesos zombis y huÃ©rfanos

Ahora, vamos a entender dos tipos de procesos especiales en UNIX/Linux: procesos zombis y procesos huÃ©rfanos.
Procesos Zombis

Un proceso zombi es un proceso que ha terminado su ejecuciÃ³n, pero su entrada aÃºn persiste en la tabla de procesos del sistema porque su proceso padre no ha leÃ­do su estado de salida usando wait().

Este tipo de proceso no consume CPU, pero ocupa espacio en la tabla de procesos, lo cual puede ser un problema si se acumulan muchos procesos zombis.

Ejemplo de proceso zombi:

    El proceso hijo termina, pero el proceso padre no llama a wait() para recoger el estado del hijo.

    El hijo permanece en la tabla de procesos como un proceso zombi hasta que el padre lo "recoja".

ðŸ“Œ SimulaciÃ³n de un proceso zombi en Python:

import os
import time

pid = os.fork()

if pid == 0:  # CÃ³digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecutÃ¡ndose...")
    time.sleep(2)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # CÃ³digo del padre (no usa wait())
    print(f"Padre (PID {os.getpid()}) no espera al hijo.")
    time.sleep(10)  # El padre no espera, dejando al hijo como zombi
    print(f"Padre (PID {os.getpid()}) termina.")

ðŸ”¹ Ejecuta esto y usa ps aux | grep Z para buscar procesos zombis.
El proceso hijo deberÃ­a aparecer como un proceso zombi en la salida.
Procesos HuÃ©rfanos

Un proceso huÃ©rfano es un proceso cuyo proceso padre ha terminado, pero el proceso sigue ejecutÃ¡ndose. Estos procesos son adoptados por el proceso init o systemd (PID 1), que se encarga de gestionarlos.

ðŸ”¹ SimulaciÃ³n de un proceso huÃ©rfano:
Si el proceso padre termina antes de que el hijo termine, el hijo se convierte en huÃ©rfano.

ðŸ“Œ Ejemplo de proceso huÃ©rfano en Python:

import os
import time

pid = os.fork()

if pid == 0:  # CÃ³digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecutÃ¡ndose...")
    time.sleep(5)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # CÃ³digo del padre
    print(f"Padre (PID {os.getpid()}) termina rÃ¡pidamente.")
    time.sleep(1)  # El padre termina antes que el hijo

ðŸ”¹ Ejecuta esto y observa cÃ³mo el proceso hijo se convierte en huÃ©rfano, adoptado por init o systemd.
Puedes usar ps -eF para verificar la adopciÃ³n del proceso huÃ©rfano.
ðŸ“Œ Alto para puesta en comÃºn

Prueba estos ejemplos y asegÃºrate de comprender la diferencia entre un proceso zombi y huÃ©rfano.
Preguntas de comprensiÃ³n:

    Â¿QuÃ© es un proceso zombi y cÃ³mo se genera?

    Â¿CÃ³mo un proceso huÃ©rfano es gestionado en el sistema?

    Â¿QuÃ© comando puedes usar para detectar procesos zombis?
    1.Un proceso zombi es un proceso que ha terminado su ejecuciÃ³n, pero su entrada en la tabla de procesos aÃºn no ha sido eliminada porque el proceso padre no ha leÃ­do su estado de salida con wait().
    2.Un proceso huÃ©rfano es aquel cuyo proceso padre ha terminado antes que Ã©l. En ese caso, el proceso huÃ©rfano es adoptado por el proceso init o systemd, que se encarga de gestionar su finalizaciÃ³n.
    3.Puedes usar el comando ps aux | grep 'Z' para identificar procesos zombis, ya que los procesos zombis suelen aparecer con un estado 'Z' en la columna de estado.
5. Ejercicios prÃ¡cticos progresivos

Ahora que hemos cubierto los conceptos fundamentales de procesos, zombis y huÃ©rfanos, vamos a hacer algunos ejercicios prÃ¡cticos para consolidar lo aprendido. Comenzaremos con ejemplos sencillos y luego avanzaremos a aplicaciones mÃ¡s complejas.
Ejercicio 1: Crear un proceso hijo con fork()

El primer ejercicio consiste en crear un proceso hijo que imprima un mensaje y luego termine. Este es un paso bÃ¡sico para familiarizarse con el uso de fork().

Instrucciones:

    Crea un proceso hijo usando fork().

    El proceso hijo debe imprimir su PID y el del padre.

    El proceso padre debe esperar a que el hijo termine utilizando wait().

ðŸ“Œ CÃ³digo:

import os

pid = os.fork()

if pid > 0:  # Proceso padre
    print(f"Soy el padre (PID: {os.getpid()}), y mi hijo tiene PID: {pid}")
    os.wait()  # Espera a que el hijo termine
    print("El hijo ha terminado.")
else:  # Proceso hijo
    print(f"Soy el hijo (PID: {os.getpid()}) y mi padre tiene PID: {os.getppid()}")

ðŸ”¹ Ejecuta este cÃ³digo y observa cÃ³mo el padre espera al hijo.
Ejercicio 2: Crear un servidor simple multiproceso

En este ejercicio, vamos a crear un servidor simple que simula un servidor de echo utilizando mÃºltiples procesos. El servidor espera conexiones y responde con el mismo mensaje que recibe.

Instrucciones:

    El servidor acepta mÃºltiples conexiones (simuladas como procesos) usando fork().

    Cada cliente (proceso hijo) recibe un mensaje y lo devuelve al "cliente" (proceso padre).

    El proceso padre se encarga de aceptar nuevas conexiones y esperar a que cada uno de los hijos termine.

ðŸ“Œ CÃ³digo:

import os
import time

def servidor():
    pid = os.fork()
    
    if pid > 0:  # Proceso padre (servidor)
        print(f"Servidor (PID: {os.getpid()}) esperando a clientes...")
        os.wait()  # Espera a que el hijo termine
        print("Cliente ha terminado.")
    else:  # Proceso hijo (cliente)
        print(f"Cliente (PID: {os.getpid()}) conecta al servidor...")
        time.sleep(2)  # Simula tiempo de procesamiento
        print(f"Cliente (PID: {os.getpid()}) responde al servidor.")
        os._exit(0)  # Termina el proceso hijo

servidor()

ðŸ”¹ Ejecuta este cÃ³digo y observa cÃ³mo el servidor maneja mÃºltiples clientes (procesos) de manera secuencial.
Ejercicio 3: Implementar un servidor multiproceso simple con fork() y exec()

En este ejercicio, vamos a implementar un servidor que utilice fork() para crear un proceso hijo para cada cliente y utilice exec() para ejecutar un programa externo (como ls) en el proceso hijo.

Instrucciones:

    El servidor acepta conexiones de clientes.

    Cada cliente se maneja con un nuevo proceso hijo creado con fork().

    El proceso hijo usa exec() para ejecutar el comando ls -l y luego termina.

ðŸ“Œ CÃ³digo:

import os

def servidor():
    pid = os.fork()
    
    if pid > 0:  # Proceso padre
        print(f"Servidor (PID: {os.getpid()}) espera a cliente...")
        os.wait()  # Espera a que el hijo termine
        print("Cliente ha terminado.")
    else:  # Proceso hijo
        print(f"Cliente (PID: {os.getpid()}) ejecutando 'ls -l'...")
        os.execvp("ls", ["ls", "-l"])  # Ejecuta 'ls -l' en el proceso hijo

servidor()

ðŸ”¹ Ejecuta este cÃ³digo y observa cÃ³mo el proceso hijo ejecuta ls -l como si fuera un comando del sistema.
ðŸ“Œ Alto para puesta en comÃºn

Prueba estos ejercicios y asegÃºrate de entender cÃ³mo se manejan los procesos en Python utilizando fork(), wait(), y exec().
Preguntas de comprensiÃ³n:

    Â¿QuÃ© hace el proceso padre en el primer ejercicio?

    Â¿CÃ³mo se gestionan mÃºltiples clientes en el segundo ejercicio?

    Â¿CuÃ¡l es la funciÃ³n de exec() en el tercer ejercicio?
    1.El proceso padre generalmente crea un proceso hijo usando fork() y puede esperar que termine usando wait(), gestionando recursos o realizando tareas adicionales mientras el hijo ejecuta su cÃ³digo.
    2.Los mÃºltiples clientes pueden ser gestionados mediante la creaciÃ³n de un nuevo proceso o hilo para cada uno, lo que permite que el servidor maneje varias conexiones simultÃ¡neamente.
    3.exec() reemplaza el proceso actual con otro programa. Se usa para ejecutar un programa diferente dentro de un proceso hijo, sin necesidad de crear un nuevo proceso con fork().
Â¡Excelente! ðŸŽ¯ Has comprendido perfectamente los conceptos y cÃ³mo se aplican en los ejercicios.

Si todo ha quedado claro y has logrado ejecutar los ejemplos sin problemas, podemos dar por concluida esta sesiÃ³n sobre procesos. Has aprendido lo siguiente:

    Conceptos bÃ¡sicos de procesos, su creaciÃ³n y manejo con fork(), exec() y wait().

    Manejo de procesos zombis y huÃ©rfanos, con ejemplos prÃ¡cticos.

    ImplementaciÃ³n de ejemplos prÃ¡cticos, como un servidor multiproceso bÃ¡sico.

Resumen y siguientes pasos:

    Has dominado la creaciÃ³n y manipulaciÃ³n bÃ¡sica de procesos en Python, lo cual es fundamental para comprender cÃ³mo funciona un sistema operativo a nivel de procesos.

    El siguiente paso podrÃ­a ser profundizar en otros conceptos de sistemas operativos, como la comunicaciÃ³n entre procesos (IPC), hilos, o procesos en segundo plano, pero eso se puede abordar en otro momento.