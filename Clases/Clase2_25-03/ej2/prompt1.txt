1. Fundamentos de procesos

Empecemos con lo esencial: ¬øqu√© es un proceso en un sistema operativo?
Definici√≥n formal de proceso

Un proceso es una instancia en ejecuci√≥n de un programa. Mientras que un programa es un conjunto de instrucciones almacenadas en un archivo ejecutable, un proceso es ese programa cargado en memoria y en ejecuci√≥n, gestionado por el sistema operativo.

Cada proceso tiene varios atributos importantes:

    PID (Process ID): Un identificador √∫nico asignado por el sistema.

    PPID (Parent Process ID): Identificador del proceso padre.

    Estado: Puede estar en ejecuci√≥n, esperando, suspendido o finalizado.

    Espacio de memoria: Incluye c√≥digo, datos y pila de ejecuci√≥n.

    Recursos asignados: Como archivos abiertos y uso de CPU.

Diferencias entre programa y proceso
Caracter√≠stica	Programa	Proceso
Estado	Archivo en disco	Entidad en ejecuci√≥n en RAM
Identificador	No tiene	PID asignado por el SO
Recursos	No usa recursos	Consume CPU, memoria, archivos abiertos
Multiplicidad	Un √∫nico archivo	Puede haber m√∫ltiples procesos ejecutando el mismo programa

Ejemplo: Si ejecutas python script.py tres veces, tendr√°s tres procesos del mismo programa.
Historia y evoluci√≥n del concepto de procesos

Los primeros sistemas operativos no ten√≠an multitarea: ejecutaban un solo programa a la vez. Con el tiempo, surgieron los sistemas multiprogramados, permitiendo m√∫ltiples procesos en ejecuci√≥n simult√°nea, optimizando el uso del procesador y la memoria.

Hoy en d√≠a, los sistemas operativos modernos usan planificaci√≥n de procesos y t√©cnicas como context switching para gestionar la ejecuci√≥n de m√∫ltiples procesos eficientemente.
üìå Alto para puesta en com√∫n

Antes de seguir, verifica que has entendido los conceptos b√°sicos.
Preguntas de comprensi√≥n:

    ¬øCu√°l es la diferencia principal entre un programa y un proceso?
    1.Un programa es un conjunto de instrucciones almacenadas en un archivo, mientras que un proceso es una instancia en ejecuci√≥n de un programa, con recursos asignados como memoria y CPU.
    ¬øQu√© es un PID y por qu√© es importante?
    2.El PID (Process ID) es un n√∫mero √∫nico que identifica a cada proceso en el sistema. Es importante porque permite gestionar y controlar los procesos en ejecuci√≥n.
    ¬øQu√© sucede si ejecutamos el mismo programa varias veces?
    3.Cada ejecuci√≥n genera un proceso distinto con su propio PID, pudiendo ejecutarse de manera independiente o compartir ciertos recursos seg√∫n el sistema operativo.
2. El modelo de procesos en UNIX/Linux

En los sistemas UNIX/Linux, los procesos siguen una jerarqu√≠a bien definida. Veamos c√≥mo funciona.
Jerarqu√≠a de procesos y herencia

Cada proceso en UNIX tiene un proceso padre (PPID) y puede generar procesos hijos.
Esta estructura forma un √°rbol de procesos, donde:

    El primer proceso en el sistema (PID = 1) es init o systemd, que genera otros procesos.

    Los procesos hijos pueden crear m√°s procesos, formando una jerarqu√≠a.

Puedes visualizar esto con:

pstree -p

Ejemplo de jerarqu√≠a:

systemd(1)‚îÄ‚î¨‚îÄsshd(1000)‚îÄ‚îÄ‚îÄbash(2000)‚îÄ‚îÄ‚îÄpython3(3000)
           ‚îú‚îÄcron(1010)
           ‚îú‚îÄnginx(1020)‚îÄ‚î¨‚îÄnginx(1021)
           ‚îÇ             ‚îî‚îÄnginx(1022)

Aqu√≠ systemd es el padre de todos, bash inici√≥ un proceso python3, y nginx cre√≥ m√∫ltiples procesos hijos.
El proceso init / systemd

El primer proceso que se ejecuta en UNIX/Linux es:

    init (en sistemas antiguos)

    systemd (en sistemas modernos como Ubuntu, Fedora, Arch, etc.)

Este proceso es responsable de:

    Iniciar otros procesos esenciales.

    Administrar servicios del sistema.

    Adoptar procesos hu√©rfanos (explicaremos esto despu√©s).

Para ver el proceso systemd:

ps -fp 1

Visualizaci√≥n de procesos con herramientas del sistema

Ejercicios pr√°cticos:

    Listar los procesos activos:

ps -e

Ver los procesos de un usuario espec√≠fico (ejemplo: "juan"):

ps -u juan

Mostrar la jerarqu√≠a completa de procesos:

pstree -p

Filtrar por un proceso espec√≠fico (ejemplo: bash):

    ps aux | grep bash

üìå Alto para puesta en com√∫n

Prueba estos comandos y verifica que puedas ver los procesos en tu sistema.
Preguntas de comprensi√≥n:

    ¬øC√≥mo se organizan los procesos en UNIX/Linux?

    ¬øCu√°l es la funci√≥n del proceso init o systemd?

    ¬øQu√© comando puedes usar para ver la jerarqu√≠a de procesos en ejecuci√≥n?
    1.Los procesos se organizan en una estructura jer√°rquica, donde cada proceso tiene un padre y puede tener hijos. Esta relaci√≥n se maneja a trav√©s de PIDs y PPIDs (Parent Process ID).
    2.Son los primeros procesos que se ejecutan al arrancar el sistema y se encargan de iniciar, gestionar y supervisar otros procesos esenciales.
    3.Se puede usar pstree para visualizar los procesos en forma de √°rbol y entender su relaci√≥n entre ellos.
3. Manipulaci√≥n de procesos con Python

Ahora aprenderemos a crear y gestionar procesos en Python utilizando el m√≥dulo os.
Creaci√≥n de procesos con fork()

El sistema UNIX/Linux permite a un proceso crear un nuevo proceso con fork().
Cuando un proceso llama a fork():

    Se duplica el proceso actual, creando un hijo.

    Ambos procesos contin√∫an ejecut√°ndose desde el mismo punto.

    El proceso padre recibe el PID del hijo, mientras que el hijo recibe 0.

üìå Ejemplo de uso:

import os

pid = os.fork()  # Crea un nuevo proceso

if pid > 0:
    print(f"Proceso padre (PID: {os.getpid()}), hijo PID: {pid}")
else:
    print(f"Proceso hijo (PID: {os.getpid()}), padre PID: {os.getppid()}")

üîπ Ejecuta esto en la terminal y observa la salida.
Ejecutar otro programa con exec()

Una vez que un proceso ha hecho fork(), puede reemplazar su c√≥digo con un nuevo programa usando exec().

üìå Ejemplo:
Este c√≥digo crea un proceso hijo que ejecuta ls -l usando execvp().

import os

pid = os.fork()

if pid == 0:  # C√≥digo del hijo
    os.execvp("ls", ["ls", "-l"])
else:
    os.wait()  # El padre espera a que el hijo termine
    print("Proceso hijo finalizado.")

üîπ Ejecuta esto y observa c√≥mo el hijo ejecuta ls -l.
Esperar la terminaci√≥n de un proceso hijo (wait())

Cuando un proceso padre crea un hijo, puede esperar a que termine con wait(), evitando que queden procesos "zombis".

üìå Ejemplo:

import os
import time

pid = os.fork()

if pid == 0:  # C√≥digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecut√°ndose...")
    time.sleep(2)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # C√≥digo del padre
    print(f"Padre (PID {os.getpid()}) esperando al hijo...")
    os.wait()  # Espera a que el hijo termine
    print("El proceso hijo ha terminado.")

üîπ Ejecuta esto y observa el comportamiento.
üìå Alto para puesta en com√∫n

Ejecuta los ejemplos y verifica que comprendes c√≥mo funcionan fork(), exec(), y wait().
Preguntas de comprensi√≥n:

    ¬øQu√© hace fork() en un programa Python?

    ¬øC√≥mo puede un proceso hijo ejecutar otro programa?

    ¬øPor qu√© es importante que el proceso padre use wait()?
    1.Crea un nuevo proceso duplicando el actual. El proceso hijo recibe una copia del estado del padre y ejecuta el mismo c√≥digo desde el punto del fork().
    2.Puede usar exec() para reemplazar su c√≥digo por el de otro programa, ejecut√°ndolo en su propio espacio de proceso.
    3.Para evitar procesos zombie y asegurarse de que el hijo termine correctamente, liberando sus recursos.
4. Procesos zombis y hu√©rfanos

Ahora, vamos a entender dos tipos de procesos especiales en UNIX/Linux: procesos zombis y procesos hu√©rfanos.
Procesos Zombis

Un proceso zombi es un proceso que ha terminado su ejecuci√≥n, pero su entrada a√∫n persiste en la tabla de procesos del sistema porque su proceso padre no ha le√≠do su estado de salida usando wait().

Este tipo de proceso no consume CPU, pero ocupa espacio en la tabla de procesos, lo cual puede ser un problema si se acumulan muchos procesos zombis.

Ejemplo de proceso zombi:

    El proceso hijo termina, pero el proceso padre no llama a wait() para recoger el estado del hijo.

    El hijo permanece en la tabla de procesos como un proceso zombi hasta que el padre lo "recoja".

üìå Simulaci√≥n de un proceso zombi en Python:

import os
import time

pid = os.fork()

if pid == 0:  # C√≥digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecut√°ndose...")
    time.sleep(2)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # C√≥digo del padre (no usa wait())
    print(f"Padre (PID {os.getpid()}) no espera al hijo.")
    time.sleep(10)  # El padre no espera, dejando al hijo como zombi
    print(f"Padre (PID {os.getpid()}) termina.")

üîπ Ejecuta esto y usa ps aux | grep Z para buscar procesos zombis.
El proceso hijo deber√≠a aparecer como un proceso zombi en la salida.
Procesos Hu√©rfanos

Un proceso hu√©rfano es un proceso cuyo proceso padre ha terminado, pero el proceso sigue ejecut√°ndose. Estos procesos son adoptados por el proceso init o systemd (PID 1), que se encarga de gestionarlos.

üîπ Simulaci√≥n de un proceso hu√©rfano:
Si el proceso padre termina antes de que el hijo termine, el hijo se convierte en hu√©rfano.

üìå Ejemplo de proceso hu√©rfano en Python:

import os
import time

pid = os.fork()

if pid == 0:  # C√≥digo del hijo
    print(f"Hijo (PID {os.getpid()}) ejecut√°ndose...")
    time.sleep(5)
    print(f"Hijo (PID {os.getpid()}) finaliza.")
else:  # C√≥digo del padre
    print(f"Padre (PID {os.getpid()}) termina r√°pidamente.")
    time.sleep(1)  # El padre termina antes que el hijo

üîπ Ejecuta esto y observa c√≥mo el proceso hijo se convierte en hu√©rfano, adoptado por init o systemd.
Puedes usar ps -eF para verificar la adopci√≥n del proceso hu√©rfano.
üìå Alto para puesta en com√∫n

Prueba estos ejemplos y aseg√∫rate de comprender la diferencia entre un proceso zombi y hu√©rfano.
Preguntas de comprensi√≥n:

    ¬øQu√© es un proceso zombi y c√≥mo se genera?

    ¬øC√≥mo un proceso hu√©rfano es gestionado en el sistema?

    ¬øQu√© comando puedes usar para detectar procesos zombis?
    1.Un proceso zombi es un proceso que ha terminado su ejecuci√≥n, pero su entrada en la tabla de procesos a√∫n no ha sido eliminada porque el proceso padre no ha le√≠do su estado de salida con wait().
    2.Un proceso hu√©rfano es aquel cuyo proceso padre ha terminado antes que √©l. En ese caso, el proceso hu√©rfano es adoptado por el proceso init o systemd, que se encarga de gestionar su finalizaci√≥n.
    3.Puedes usar el comando ps aux | grep 'Z' para identificar procesos zombis, ya que los procesos zombis suelen aparecer con un estado 'Z' en la columna de estado.
5. Ejercicios pr√°cticos progresivos

Ahora que hemos cubierto los conceptos fundamentales de procesos, zombis y hu√©rfanos, vamos a hacer algunos ejercicios pr√°cticos para consolidar lo aprendido. Comenzaremos con ejemplos sencillos y luego avanzaremos a aplicaciones m√°s complejas.
Ejercicio 1: Crear un proceso hijo con fork()

El primer ejercicio consiste en crear un proceso hijo que imprima un mensaje y luego termine. Este es un paso b√°sico para familiarizarse con el uso de fork().

Instrucciones:

    Crea un proceso hijo usando fork().

    El proceso hijo debe imprimir su PID y el del padre.

    El proceso padre debe esperar a que el hijo termine utilizando wait().

üìå C√≥digo:

import os

pid = os.fork()

if pid > 0:  # Proceso padre
    print(f"Soy el padre (PID: {os.getpid()}), y mi hijo tiene PID: {pid}")
    os.wait()  # Espera a que el hijo termine
    print("El hijo ha terminado.")
else:  # Proceso hijo
    print(f"Soy el hijo (PID: {os.getpid()}) y mi padre tiene PID: {os.getppid()}")

üîπ Ejecuta este c√≥digo y observa c√≥mo el padre espera al hijo.
Ejercicio 2: Crear un servidor simple multiproceso

En este ejercicio, vamos a crear un servidor simple que simula un servidor de echo utilizando m√∫ltiples procesos. El servidor espera conexiones y responde con el mismo mensaje que recibe.

Instrucciones:

    El servidor acepta m√∫ltiples conexiones (simuladas como procesos) usando fork().

    Cada cliente (proceso hijo) recibe un mensaje y lo devuelve al "cliente" (proceso padre).

    El proceso padre se encarga de aceptar nuevas conexiones y esperar a que cada uno de los hijos termine.

üìå C√≥digo:

import os
import time

def servidor():
    pid = os.fork()
    
    if pid > 0:  # Proceso padre (servidor)
        print(f"Servidor (PID: {os.getpid()}) esperando a clientes...")
        os.wait()  # Espera a que el hijo termine
        print("Cliente ha terminado.")
    else:  # Proceso hijo (cliente)
        print(f"Cliente (PID: {os.getpid()}) conecta al servidor...")
        time.sleep(2)  # Simula tiempo de procesamiento
        print(f"Cliente (PID: {os.getpid()}) responde al servidor.")
        os._exit(0)  # Termina el proceso hijo

servidor()

üîπ Ejecuta este c√≥digo y observa c√≥mo el servidor maneja m√∫ltiples clientes (procesos) de manera secuencial.
Ejercicio 3: Implementar un servidor multiproceso simple con fork() y exec()

En este ejercicio, vamos a implementar un servidor que utilice fork() para crear un proceso hijo para cada cliente y utilice exec() para ejecutar un programa externo (como ls) en el proceso hijo.

Instrucciones:

    El servidor acepta conexiones de clientes.

    Cada cliente se maneja con un nuevo proceso hijo creado con fork().

    El proceso hijo usa exec() para ejecutar el comando ls -l y luego termina.

üìå C√≥digo:

import os

def servidor():
    pid = os.fork()
    
    if pid > 0:  # Proceso padre
        print(f"Servidor (PID: {os.getpid()}) espera a cliente...")
        os.wait()  # Espera a que el hijo termine
        print("Cliente ha terminado.")
    else:  # Proceso hijo
        print(f"Cliente (PID: {os.getpid()}) ejecutando 'ls -l'...")
        os.execvp("ls", ["ls", "-l"])  # Ejecuta 'ls -l' en el proceso hijo

servidor()

üîπ Ejecuta este c√≥digo y observa c√≥mo el proceso hijo ejecuta ls -l como si fuera un comando del sistema.
üìå Alto para puesta en com√∫n

Prueba estos ejercicios y aseg√∫rate de entender c√≥mo se manejan los procesos en Python utilizando fork(), wait(), y exec().
Preguntas de comprensi√≥n:

    ¬øQu√© hace el proceso padre en el primer ejercicio?

    ¬øC√≥mo se gestionan m√∫ltiples clientes en el segundo ejercicio?

    ¬øCu√°l es la funci√≥n de exec() en el tercer ejercicio?
    1.El proceso padre generalmente crea un proceso hijo usando fork() y puede esperar que termine usando wait(), gestionando recursos o realizando tareas adicionales mientras el hijo ejecuta su c√≥digo.
    2.Los m√∫ltiples clientes pueden ser gestionados mediante la creaci√≥n de un nuevo proceso o hilo para cada uno, lo que permite que el servidor maneje varias conexiones simult√°neamente.
    3.exec() reemplaza el proceso actual con otro programa. Se usa para ejecutar un programa diferente dentro de un proceso hijo, sin necesidad de crear un nuevo proceso con fork().
¬°Excelente! üéØ Has comprendido perfectamente los conceptos y c√≥mo se aplican en los ejercicios.

Si todo ha quedado claro y has logrado ejecutar los ejemplos sin problemas, podemos dar por concluida esta sesi√≥n sobre procesos. Has aprendido lo siguiente:

    Conceptos b√°sicos de procesos, su creaci√≥n y manejo con fork(), exec() y wait().

    Manejo de procesos zombis y hu√©rfanos, con ejemplos pr√°cticos.

    Implementaci√≥n de ejemplos pr√°cticos, como un servidor multiproceso b√°sico.

Resumen y siguientes pasos:

    Has dominado la creaci√≥n y manipulaci√≥n b√°sica de procesos en Python, lo cual es fundamental para comprender c√≥mo funciona un sistema operativo a nivel de procesos.

    El siguiente paso podr√≠a ser profundizar en otros conceptos de sistemas operativos, como la comunicaci√≥n entre procesos (IPC), hilos, o procesos en segundo plano, pero eso se puede abordar en otro momento.